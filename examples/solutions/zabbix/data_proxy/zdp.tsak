//
// TSAK Zabbix Data Proxy
//
fmt     = import("fmt")
net     = import("net")
zabbix  = import("protocols/zabbix")
log     = import("tlog")
stdlib  = import("stdlib")
time    = import("time")
djson   = import("djson")
ioutil  = import("io/ioutil")

C = 0


func ServerHB() {
  log.Trace("Server heartbeat")
  snd = zabbix.Request("proxy heartbeat", PROXYNAME, COMPRESS)
  if ! zabbix.TwoWay(SERVER, snd, TIMEOUT) {
    log.Trace("ZABBIX server heartbeat failed", {"proxy":PROXYNAME, "server":SERVER})
  } else {
    log.Trace("ZABBIX server heartbeat OK")
  }
}


if VMNAME == "in" {
  //
  // Data/Configuration acquisition
  //
  func DataAcq() {
    C += 1
    if C > 15 {
      log.Trace("15-th iteration of data acquisition started")
      C = 0
    }
    dataA.Acquire(stdlib.TODO(), 1)
    snd = zabbix.Request("proxy data", PROXYNAME, COMPRESS)
    rsp = zabbix.Response("success", VERSION, COMPRESS)
    res = zabbix.ThreeWay(PROXY, snd, rsp, TIMEOUT)
    if res != nil {
      if DATAFORWARD {
        dataCH <- res.String()
      }
    }
    dataA.Release(1)
  }

  func DataForward() {
    // if ! dataS.TryAcquire(1) {
    //   fmt.Println("DF0")
    //   return
    // }
    dataS.Acquire(stdlib.TODO(), 1)
    for len(dataCH) > 0 {
      data = djson.Parse(<-dataCH)
      if DATAFORWARD {
        // Do an actual data forwarding
        zpkt = zabbix.Data("proxy data", data.String(), PROXYNAME, COMPRESS)
        res  = zabbix.TwoWay(SERVER, zpkt, TIMEOUT)
        if ! res {
          log.Trace("ZABBIX data forwarding delivery failed")
        }
      }
      stdlib.To(stdlib.INCH, data.String())
    }
    dataS.Release(1)
  }
  func ConfAcq() {
    log.Trace("Configuration acquisition started")
    snd = zabbix.Request("proxy config", PROXYNAME, COMPRESS)
    rsp = zabbix.Response("success", VERSION, COMPRESS)
    res = zabbix.ThreeWay(SERVER, snd, rsp, TIMEOUT)
    if res != nil {
      confCH <- res.String()
      stdlib.To(stdlib.INCH, res.String())
    } else {
      log.Trace("ZABBIX server failed to provide a proxy configuration", {"proxy":PROXYNAME, "server":SERVER})
    }
  }

  func ConfDelivery() {
    log.Trace("Configuration delivery started")
    conf = djson.Parse(<-confCH)
    zpkt = zabbix.Data("proxy config", conf.String(), PROXYNAME, COMPRESS)
    res  = zabbix.TwoWay(PROXY, zpkt, TIMEOUT)
    if res {
      log.Trace("ZABBIX proxy configuration delivery OK")
    } else {
      log.Trace("ZABBIX proxy configuration delivery failed")
    }
  }
  //
  // Set-up CRONTAB functions
  //
  confCH = make(chan string, DISTCHANNELS)
  dataCH = make(chan string, DISTCHANNELS)
  dataA = stdlib.Semaphore(1)
  dataS = stdlib.Semaphore(1)
  stdlib.Cron(CONFACQCRON,      ConfAcq)
  stdlib.Cron(CONFDELIVERYCRON, ConfDelivery)
  stdlib.Cron(SERVERHBCRON,     ServerHB)
  stdlib.Cron(DATAACQCRON,      DataAcq)
  stdlib.Cron(DATAFORWARDCRON,  DataForward)
  for ! stdlib.ExitRequested() {
    time.Sleep(INLOOPWAIT * time.Second)
  }

} else if VMNAME == "proc" {
  //
  // Data processor
  //
  time.Sleep(1 * time.Second)
  for ! stdlib.ExitRequested() {
    for stdlib.Len(stdlib.INCH) > 0 {
      data = stdlib.From(stdlib.INCH)
      fmt.Println("RECEIVED IN PROC", len(stdlib.String(data)), "bytes")
      // stdlib.To(stdlib.OUTCH, data)
    }
    log.Trace("PROC() is cooled down")
    time.Sleep(PROCLOOPWAIT * time.Second)
  }
} else if VMNAME == "out" {
  //
  // Data delivery
  //
  time.Sleep(1 * time.Second)
  for ! stdlib.ExitRequested() {
    time.Sleep(OUTLOOPWAIT * time.Second)
  }
} else if VMNAME == "house" {
  //
  // Housekeeper
  //
} else {
  log.Trace("If you see this message, please open a bug report")
}
